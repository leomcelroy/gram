http://leomcelroy.com/proto-plum/index.html

----- april 17, 2021 ------

def add x y: x + y

def addn n {
  \x { add n x } 
}

add3 = addn 3

print (add3 3) == 6
 
would like to fix function scoping so this works
maybe remove holes then
clarify the call model

a even clearer test is

def test n:
  z = 3
  \: z + n

print @test 2

got previous to work but this pattern still wont

def state:
  x = 4
  dict[
    "inc": x = x + 1
    "get": \:x
  ]

print state.inc
print state.get

I guess I don't really need it to

-------------------------

dict blocks

TODO --- feb 19, 2021 ---
- dogbone bug
- interior exterior corner rounding
- indicate construction line
- names for files
x - show turtle
x - unary operator precedence
------

TODO --- feb 13, 2021 ---
X - bezier bezier “M 10 10 L 10 10”
string interpolations “goto {10} 2”
x - make direct manipulations work in layers
add animation option
------


call first class functions better
what situations do I have issues with

TODO Nov 14
web worker for parser
block comment hotkey
expansion
	-what does cuttle do?
	-talk to paula
better rounding


haskell-y
creating functions automatically when passing variables

white space blocks

what block syntax do I prefer
do/end or {}
{} is more terse and perhaps common
looks more like code though

I think I don't like the aestetic
better on one line

do/end don't stand out
easier to say
easier to type for foreign keyboards

//////////////////////////////////////////////////////////////////////
how should if ... else statements work
right now it just parsers next expression
if true then dothing else otherthing

can make branching blocks using ()
if true then (
	dothing
	andmorething
) else if othertrue then (
	dootherthing
) else (
	wedone
	withit
)

---VS---

if true then
	dothing
	andmorething
else if othertrue then
	dootherthing
else
	wedone
	withit
end

---VS---

if true
	dothing
	andmorething
else if othertrue
	dootherthing
else
	wedone
	withit
end

---VS---

if true
	dothing
	plusonemore
elif othertrue
	dontforget
	overhere
else
	fallback
	onthis
end

---VS---

if true {
	dothing
	plusonemore
} else if othertrue {
	dontforget
	overhere
} else {
	fallback
	onthis
}

SINGLE LINE BECOMES

x = if true then 10 else 3

x = if true 10 else 3 end
// second one lacks separation between clause and value
// could use my optional commas which I'm still debating
x = if true, 10 else 3 end

//////////////////////////////////////////////////////////////////////

sin

returned functions are not evaled, and that is maybe okay
for example this wont work
def add :[ :x :y [x+y] ]
add 10 10
kind of makes sense because otherwise function definitions would immediately evaluate

should lists be evaled when passed as arguments

Should I add a stop keyword which terminates the running function
Maybe I just need early return

if first line of function body is symbol and I have no parameters then it will be read as a name
def
	x = 10
	x + 10
end

To support first class functions I think I need call syntax
could use period to denote function call
add. 1 2
neg. 1 + 2 == -3
neg.1 + 2 == 1

could signify arity when unknown with f.{3} 

x is 20
x isnt 20

x and 3
x or 3
not x

sum = :x 
	for i in x i*2 end 
end

sum([5 4 3 1 2 3]) + sum([2 3])

[1 2 3]
map _ => for i in _ i*2 end end

add = :x :y => x + y end
add = (x y) => x + y end
doThing = => thing() end
add! ;1 ;2
add(1 2)
doThing() 
doThing = => thing() end

<- ->
:=
no argument needs =>
--- TODO ---
- negative numbers
- autocomplete with default params

X - autocomplete
X - syntax and keyword highlighting
X - stack overflow bug

dropdown for selected params
X - scrubbable numbers


for loop around multiple creates infinite loop

no function definitions in loops

DONE
color should be paired to path not to turtle
if it's paired to turtle it get's destroyed when turtles are merged

TODO

repeat
mirror
fillet

right 90
forward 30
strokewidth 5

to shape
	rectangle 20 20
	#circle 20
end

new

shape
color "black"

new

shape
translate (width x) 0
color "red"
set "x"

new

shape
color "green"
moveto (xof max x) 0 "min max"


add = :x :y => x + y end
add(0 1 2 3 4 5 6) 

sum = :x 0 for i in x _+i end _[0];
sum([5 4 3 1 2 3]) + sum([2 3])